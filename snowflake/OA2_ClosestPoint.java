package com.company.review.algorithms;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

/**
 * @Author Derrick
 * @CreateTime 6/26/2020 10:25 PM
 * @Desc
 */
public class Closest {
    static class Point{
        int x;
        int y;
        public Point(int x, int y){
            this.x = x;
            this.y = y;
        }
    }

    /**
     * Main idea of my solution is using DIVIDE AND CONQUER.
     * Keep dividing the set of points into two partitions, and calculate the shortest distance.
     * There will be three situations from which shortest distance is generated:
     * 1. Generated from two points which are from left partition.
     * 2. Generated from two points which are from right partition.
     * 3. Generated from two points which are from different partitions.
     * Cases 1 and 2 are easy to understand, but as for case 3, there are some tricks to get the result more efficiently.
     * Before dealing with case 3, the minimum distance from case 1 and 2 is generated, let's call it "dis". Thus, the coordinate x of the points in the case 3 should
     * lie in the region (mid - dis, mid) and (mid, mid + dis), cause only in this case, the distance of two points which are from different partitions is possible to be less than dis.
     * After putting every point which conforms to the rule mentioned above into a list, then we can calculate the distances of every two points in the list.
     * But actually, we don't need to calculate every pair of points in the list, for each point (x, y), we just need to pick up the points whose coordinate y' is in the region (y - dis, y) and (y, y + dis).
     * @param x
     * @param y
     * @return
     */
    static long closestSquaredDistance(List<Integer> x, List<Integer> y) {
        int len = x.size();
        Point[] points = new Point[len];
        for (int i = 0; i < len; i++){
            Point point = new Point(x.get(i), y.get(i));
            points[i] = point;
        }
        //Sort the points array with ascending order of coordinates x.
        //Then we can divide array in the following method "divide".
        Arrays.sort(points, new Comparator<Point>() {
            @Override
            public int compare(Point o1, Point o2) {
                return Integer.compare(o1.x, o2.x);
            }
        });

        return divide(0, len - 1, points);
    }

    static long divide(int left, int right, Point[] points){
        long dis = Long.MAX_VALUE;
        if (left == right){
            return 0;
        }
        if (left + 1 == right){
            return distance(points[left], points[right]);
        }

        int mid = left + (right - left) / 2;
        //Calculate the shortest distances of the points which are both in the same partition,
        //then we can get shortest distance from left region and right region.
        long leftMin = divide(left, mid, points);
        long rightMin = divide(mid, right, points);

        dis = Math.min(leftMin, rightMin);

        //Assume that the shortest distance is generated by two points which are in different partition.
        List<Point> list = new ArrayList<>();
        for (int i = left; i <= right; i++){
            if (Math.abs(points[i].x - points[mid].x) <= dis){
                list.add(points[i]);
            }
        }
        for (int i = 0; i < list.size() - 1; i++){
            for (int j = i + 1; j < list.size(); j++){
                if (Math.abs(list.get(i).y - list.get(j).y) > dis){
                    continue;
                }
                long tmpDis = distance(list.get(i), list.get(j));
                dis = Math.min(tmpDis, dis);
            }
        }

        return dis;
    }

    static long distance(Point p1, Point p2) {
        return (long)((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
    }

    public static void main(String[] args) {
        List<Integer> x = Arrays.asList(0, 10, 15);
        List<Integer> y = Arrays.asList(0, 10, 20);
        closestSquaredDistance(x, y);
    }
}
